// https://tlx.toki.id/submissions/1065162

#include <bits/stdc++.h>
using namespace std;
#define int long long

const int M = 998244353;

struct Segtree {
    vector<int> t, lazy;
    int n;

    Segtree(int n) : n(n)
    {
        t.resize(4 * n);
        lazy.resize(4 * n);
    }

    int add(int a, int b)
    {
        return (a + b) % M;
    }

    void push(int v, int l, int r)
    {
        if(lazy[v])
        {
            t[v] = add(t[v], (lazy[v] * (r - l + 1)) % M);
            if(l != r)
            {
                lazy[v * 2] = add(lazy[v * 2], lazy[v]);
                lazy[v * 2 + 1] = add(lazy[v * 2 + 1], lazy[v]);
            }
            lazy[v] = 0;
        }
    }

    void update(int v, int l, int r, int ql, int qr, int val)
    {
        push(v, l, r);
        if(l > qr || r < ql) return;
        if(ql <= l && qr >= r)
        {
            lazy[v] = val;
            push(v, l, r);
            return;
        }
        int mid = (l + r) / 2;
        update(v * 2, l, mid, ql, qr, val);
        update(v * 2 + 1, mid + 1, r , ql, qr, val);
        t[v] = add(t[v * 2], t[v * 2 + 1]);
    }   

    int query(int v, int l, int r, int ql, int qr)
    {
        push(v, l, r);
        if(l > qr || r < ql) return 0;
        if(ql <= l && qr >= r) return t[v];
        int mid = (l + r) / 2;
        return add(query(v * 2, l, mid, ql, qr), query(v * 2 + 1, mid + 1, r, ql, qr));
    }

};

signed main(){
    cin.tie(0) -> ios_base::sync_with_stdio(0);

    int n;
    cin >> n;

    Segtree s(n + 1);
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }

    vector<int> g[n + 1], pr(n + 1); 
    for(int i = 0; i < n - 1; i++)
    {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    vector<int> st(n + 1), en(n + 1), time(n + 1);

    queue<int> q;
    q.push(1);
    int timer = 0;
    while(!q.empty())
    {
        int u = q.front(); q.pop();
        time[u] = ++timer;
        for(auto v : g[u])
        {
            if(time[v] == 0)
            {
                q.push(v);
                pr[v] = u;
            }
        }
    }

    for(int i = 1; i <= n; i++) s.update(1, 1, n, time[i], time[i], a[i]);

    for(int i = 1; i <= n; i++)
    {
        st[time[i]] = 1e18;
        for(auto v : g[i])
        {
            if(v != pr[i])
            {
                st[time[i]] = min(st[time[i]], time[v]);
                en[time[i]] = max(en[time[i]], time[v]);
            }
        }
        if(st[time[i]] == 1e18) st[time[i]] = 0;
    }

    // for(int i = 1; i <= n; i++) cout << st[i] << " " ; cout << '\n';
    // for(int i = 1; i <= n; i++) cout << en[i] << " "; cout << '\n';
    // for(int i = 1; i <= n; i++)
    // {
    //     cout << i << " : " << time[i] << " = " << s.query(1, 1, n, i, i) << '\n';
    // }

    int Q;
    cin >> Q;
    while(Q--)
    {
        int t, x;
        cin >> t >> x;
        if(t == 1)
        {   
            int z = s.query(1, 1, n, time[x], time[x]);
            // cout << "cur = " << z << " " << en[time[x]] << '\n';
            s.update(1, 1, n, st[time[x]], en[time[x]], z);
            s.update(1, 1, n, time[pr[x]], time[pr[x]], z);
        }
        else
        {
            int a = 0;
            if(st[time[x]] != 0)
            {
                a = s.query(1, 1, n, st[time[x]], en[time[x]]);
            }
            int b = 0;
            if(pr[x] != 0)
            {
                b = s.query(1, 1, n, time[pr[x]], time[pr[x]]);;
            }
            // cout << a << " " << b << '\n';
            cout << (a + b) % M << '\n';
            
        }
    }

}
